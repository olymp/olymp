import { Kind } from 'graphql/language';
import { GraphQLError } from 'graphql/error';
import { GraphQLScalarType } from 'graphql';

var assertErr = require('assert-err');

export default {
  schema: '\n    scalar DateTime\n  ',
  resolvers: {
    DateTime: new GraphQLScalarType({
      name: 'DateTime',
      description: 'DateType as Integer',
      serialize: function serialize(value) {
        if (typeof value === 'number' || typeof value === 'string') {
          value = new Date(value);
        }
        assertErr(value instanceof Date, TypeError, 'Field error: value is not an instance of Date');
        assertErr(!isNaN(value.getTime()), TypeError, 'Field error: value is an invalid Date');
        return +value;
      },
      parseValue: function parseValue(value) {
        var date = new Date(value);
        assertErr(!isNaN(date.getTime()), TypeError, 'Field error: value is an invalid Date');
        return date;
      },
      parseLiteral: function parseLiteral(ast) {
        if (ast.kind !== Kind.INT) {
          throw new GraphQLError('Query error: Can only parse INT got a: ' + ast.kind + '.', [ast]);
        }
        var result = new Date(ast.value);
        assertErr(!isNaN(result.getTime()), GraphQLError, 'Query error: Invalid date', [ast]);
        assertErr(ast.value === result.toJSON(), GraphQLError, 'Query error: Invalid date format', [ast]);
        return ast.value;
      }
    })
  }
};
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2dyYXBocWwvc2VydmVyL3NjYWxhcnMvZGF0ZS10aW1lLmVzNiJdLCJuYW1lcyI6WyJLaW5kIiwiR3JhcGhRTEVycm9yIiwiR3JhcGhRTFNjYWxhclR5cGUiLCJhc3NlcnRFcnIiLCJyZXF1aXJlIiwic2NoZW1hIiwicmVzb2x2ZXJzIiwiRGF0ZVRpbWUiLCJuYW1lIiwiZGVzY3JpcHRpb24iLCJzZXJpYWxpemUiLCJ2YWx1ZSIsIkRhdGUiLCJUeXBlRXJyb3IiLCJpc05hTiIsImdldFRpbWUiLCJwYXJzZVZhbHVlIiwiZGF0ZSIsInBhcnNlTGl0ZXJhbCIsImFzdCIsImtpbmQiLCJJTlQiLCJyZXN1bHQiLCJ0b0pTT04iXSwibWFwcGluZ3MiOiJBQUFBLFNBQVNBLElBQVQsUUFBcUIsa0JBQXJCO0FBQ0EsU0FBU0MsWUFBVCxRQUE2QixlQUE3QjtBQUNBLFNBQVNDLGlCQUFULFFBQWtDLFNBQWxDOztBQUVBLElBQU1DLFlBQVlDLFFBQVEsWUFBUixDQUFsQjs7QUFFQSxlQUFlO0FBQ2JDLHFDQURhO0FBSWJDLGFBQVc7QUFDVEMsY0FBVSxJQUFJTCxpQkFBSixDQUFzQjtBQUM5Qk0sWUFBTSxVQUR3QjtBQUU5QkMsbUJBQWEscUJBRmlCO0FBRzlCQyxlQUg4QixxQkFHcEJDLEtBSG9CLEVBR2I7QUFDZixZQUFJLE9BQU9BLEtBQVAsS0FBaUIsUUFBakIsSUFBNkIsT0FBT0EsS0FBUCxLQUFpQixRQUFsRCxFQUE0RDtBQUMxREEsa0JBQVEsSUFBSUMsSUFBSixDQUFTRCxLQUFULENBQVI7QUFDRDtBQUNEUixrQkFDRVEsaUJBQWlCQyxJQURuQixFQUVFQyxTQUZGLEVBR0UsK0NBSEY7QUFLQVYsa0JBQVUsQ0FBQ1csTUFBTUgsTUFBTUksT0FBTixFQUFOLENBQVgsRUFBbUNGLFNBQW5DLEVBQThDLHVDQUE5QztBQUNBLGVBQU8sQ0FBQ0YsS0FBUjtBQUNELE9BZDZCO0FBZTlCSyxnQkFmOEIsc0JBZW5CTCxLQWZtQixFQWVaO0FBQ2hCLFlBQU1NLE9BQU8sSUFBSUwsSUFBSixDQUFTRCxLQUFULENBQWI7QUFDQVIsa0JBQVUsQ0FBQ1csTUFBTUcsS0FBS0YsT0FBTCxFQUFOLENBQVgsRUFBa0NGLFNBQWxDLEVBQTZDLHVDQUE3QztBQUNBLGVBQU9JLElBQVA7QUFDRCxPQW5CNkI7QUFvQjlCQyxrQkFwQjhCLHdCQW9CakJDLEdBcEJpQixFQW9CWjtBQUNoQixZQUFJQSxJQUFJQyxJQUFKLEtBQWFwQixLQUFLcUIsR0FBdEIsRUFBMkI7QUFDekIsZ0JBQU0sSUFBSXBCLFlBQUosNkNBQTJEa0IsSUFBSUMsSUFBL0QsUUFBd0UsQ0FBQ0QsR0FBRCxDQUF4RSxDQUFOO0FBQ0Q7QUFDRCxZQUFNRyxTQUFTLElBQUlWLElBQUosQ0FBU08sSUFBSVIsS0FBYixDQUFmO0FBQ0FSLGtCQUFVLENBQUNXLE1BQU1RLE9BQU9QLE9BQVAsRUFBTixDQUFYLEVBQW9DZCxZQUFwQyxFQUFrRCwyQkFBbEQsRUFBK0UsQ0FBQ2tCLEdBQUQsQ0FBL0U7QUFDQWhCLGtCQUFVZ0IsSUFBSVIsS0FBSixLQUFjVyxPQUFPQyxNQUFQLEVBQXhCLEVBQXlDdEIsWUFBekMsRUFBdUQsa0NBQXZELEVBQTJGLENBQ3pGa0IsR0FEeUYsQ0FBM0Y7QUFHQSxlQUFPQSxJQUFJUixLQUFYO0FBQ0Q7QUE5QjZCLEtBQXRCO0FBREQ7QUFKRSxDQUFmIiwiZmlsZSI6InBhY2thZ2VzL2dyYXBocWwvc2VydmVyL3NjYWxhcnMvZGF0ZS10aW1lLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgS2luZCB9IGZyb20gJ2dyYXBocWwvbGFuZ3VhZ2UnO1xuaW1wb3J0IHsgR3JhcGhRTEVycm9yIH0gZnJvbSAnZ3JhcGhxbC9lcnJvcic7XG5pbXBvcnQgeyBHcmFwaFFMU2NhbGFyVHlwZSB9IGZyb20gJ2dyYXBocWwnO1xuXG5jb25zdCBhc3NlcnRFcnIgPSByZXF1aXJlKCdhc3NlcnQtZXJyJyk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgc2NoZW1hOiBgXG4gICAgc2NhbGFyIERhdGVUaW1lXG4gIGAsXG4gIHJlc29sdmVyczoge1xuICAgIERhdGVUaW1lOiBuZXcgR3JhcGhRTFNjYWxhclR5cGUoe1xuICAgICAgbmFtZTogJ0RhdGVUaW1lJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnRGF0ZVR5cGUgYXMgSW50ZWdlcicsXG4gICAgICBzZXJpYWxpemUodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEVycihcbiAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIERhdGUsXG4gICAgICAgICAgVHlwZUVycm9yLFxuICAgICAgICAgICdGaWVsZCBlcnJvcjogdmFsdWUgaXMgbm90IGFuIGluc3RhbmNlIG9mIERhdGUnLFxuICAgICAgICApO1xuICAgICAgICBhc3NlcnRFcnIoIWlzTmFOKHZhbHVlLmdldFRpbWUoKSksIFR5cGVFcnJvciwgJ0ZpZWxkIGVycm9yOiB2YWx1ZSBpcyBhbiBpbnZhbGlkIERhdGUnKTtcbiAgICAgICAgcmV0dXJuICt2YWx1ZTtcbiAgICAgIH0sXG4gICAgICBwYXJzZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICAgIGFzc2VydEVycighaXNOYU4oZGF0ZS5nZXRUaW1lKCkpLCBUeXBlRXJyb3IsICdGaWVsZCBlcnJvcjogdmFsdWUgaXMgYW4gaW52YWxpZCBEYXRlJyk7XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgfSxcbiAgICAgIHBhcnNlTGl0ZXJhbChhc3QpIHtcbiAgICAgICAgaWYgKGFzdC5raW5kICE9PSBLaW5kLklOVCkge1xuICAgICAgICAgIHRocm93IG5ldyBHcmFwaFFMRXJyb3IoYFF1ZXJ5IGVycm9yOiBDYW4gb25seSBwYXJzZSBJTlQgZ290IGE6ICR7YXN0LmtpbmR9LmAsIFthc3RdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgRGF0ZShhc3QudmFsdWUpO1xuICAgICAgICBhc3NlcnRFcnIoIWlzTmFOKHJlc3VsdC5nZXRUaW1lKCkpLCBHcmFwaFFMRXJyb3IsICdRdWVyeSBlcnJvcjogSW52YWxpZCBkYXRlJywgW2FzdF0pO1xuICAgICAgICBhc3NlcnRFcnIoYXN0LnZhbHVlID09PSByZXN1bHQudG9KU09OKCksIEdyYXBoUUxFcnJvciwgJ1F1ZXJ5IGVycm9yOiBJbnZhbGlkIGRhdGUgZm9ybWF0JywgW1xuICAgICAgICAgIGFzdCxcbiAgICAgICAgXSk7XG4gICAgICAgIHJldHVybiBhc3QudmFsdWU7XG4gICAgICB9LFxuICAgIH0pLFxuICB9LFxufTtcbiJdfQ==
